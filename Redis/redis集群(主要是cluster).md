## Redis集群

- 分布式方案
  1. 客户端分区：Redis cluster 、客户端分区
  2. 代理分区：TwemProxy、Codis

Redis集群是Redis提供的分布式数据库方案, 集群通过分片的方式来进行数据的共享, 并提供复制和故障转移功能.

### Redis Cluster

### 一. 节点

一个Redis集群通常由多个节点(Node)组成, 要组建真正一个可工作的集群, 必须将各个独立的节点连接起来, 构成一个包含多个节点的集群.
连接各个节点可以使用 CLUSTER MEET命令, 让node节点与指定 ip和port 的节点进行握手. node节点就会将所指定的节点添加到当前所在的集群中.

![1568560980263](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568560980263.png)

![1568561012994](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568561012994.png)

1. ### 集群数据结构 

  clusterNode结构保存了一个节点的当前状态, 比如节点的创建时间, 节点的名称, 节点的IP地址和端口号等等. 每个节点都会使用clusterNode结构来记录自己的状态. 并为集群中的所有其他节点都创建一个相应的clusterNode结构, 以此记录其他节点的状态.

  ![1568561061359](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568561061359.png)

  每个节点都保存着一个clusterState结构, 这个结构记录了在当前节点的视角下, 集群目前所处的状态.

  ![1568561138618](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568561138618.png)

  ![1568561208389](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568561208389.png)

2. ### CLUSTER MEET命令的实现

  通过向节点A发送 CLUSTER MEET命令, 客户端可以让接受命令的节点A将另一个节点B添加到当前结点A所在的集群中:

  ![1568561246884](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568561246884.png)之后, 节点A会将节点B的信息传播给集群中所有的其他节点, 让其他节点也与B进行握手, 终, 节点B会被集群中所有节点认识.

  ### 二. 槽指派

  Redis集群通过分片的方式来保存数据库中的键值对: 集群的整个数据库被分为16384个槽, 数据库中的每个键都属于这16384个槽中的其中一个, 集群中的每个节点可以处理0个或者多16384个槽.当数据库中的16384个槽都有节点在处理时, 集群处于上线状态, 如果数据库中有任何一个槽没有得到处理, 那么集群处于下线状态.

  上述案例中, 使用CLUSTER MEET 命令将7000, 7001, 7002三个节点连接到同一个集群里面, 不过这个集群仍处于下线状态, 因为集群中的三个节点都没有在处理任何槽.

  ![1568561387695](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568561387695.png)

  - ### 记录节点的槽指派信息

  clusterNode结构的slots属性和numslot属性记录了节点负责处理那哪些槽. 
  Redis以0为起始索引, 16383为终止索引, 对slots数组中的16384个二进制位进行编号, 并根据索引 i 上的二进制位的值来判断节点是否负责处理槽 i. 

  - ### 传播节点的槽指派信息

  一个节点会将自己的slots数组通过消息发送给集群中的其他节点, 以此来告知其他节点自己目前负责处理哪些槽.

  - ### 记录集群中所有槽的指派信息

  clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息:
  如果slots[i]指针指向null, 那么表示槽 i 尚未指派给任何节点.
  如果 slots[i] 指针指向一个 clusterNode 结构, 表示该槽已经指派给 clusterNode所代表的的节点. 
  将所有槽的指派信息保存在clusterState.slots数组里面, 程序要检查槽 i 是否被指派, 主要访问 clusterState.slots[i] 的值即可. 操作时间复杂度为O(1).
  三. 在集群中执行命令
  当客户端向节点发送命令时, 接收命令的节点会计算出命令要处理的数据库键属于哪个槽, 并检查这个槽是否指派给了自己.
  (1)如果当前键所在的槽正好指派给当前节点, 那么节点直接执行这个命令.
  (2)如果当前键所在的槽并没有指派给当前节点, 那么节点会向客户端发送一个MOVED错误, 指引客户端转至正确节点.

  - ### 计算键属于哪一个槽

  节点使用以下算法来计算给定的key属于哪个槽:

  - ### 节点数据库的实现

  集群节点保存键值对的方式和单机Redis服务器完全相同. 
  节点和单机服务器在数据库方面的一个区别是, 节点只能使用0号数据库, 而单机Redis服务器则没有这一限制.

  ### 四. 重新分片

  Redis集群的重新分片操作可以将任意数量的已经指派给某个节点的槽改为指派给另一个节点, 并且相关槽所属的键值对也会从源节点移动到目标节点.
  五. ASK错误
  在进行重新分片期间, 源节点向目标节点迁移一个槽的过程中, 可能存在这样一种情况: 属于被迁移槽的一部分键值对保存在源节点里面, 另一部分键值对则保存在目标节点里面.当客户端向源节点发送一个与数据库键有关的命令, 并且数据库键恰好处于正在被迁移的槽时: 源节点会先在自己的数据库里面查找指定的键, 如果找到, 直接执行客户端发送的命令.
  如果源节点没有找到指定的键, 那么这个键很有可能已经被迁移到目标节点, 源节点会向客户端返回ASK错误, 引导客户端转向正在导入槽的目标节点.
  六. 复制与故障转移(Redis主从复制)
  Redis集群中的节点分为主节点(master)和从节点(slave). 主节点用于处理槽, 而从节点则用于复制某个主节点, 并在被复制某个主节点下线时, 代替下线主节点继续处理命令请求.如果这时, 节点7000进入下线状态, 那么集群中仍在正常运作的几个主节点将在节点7000的两个从节点-----节点7004和节点7005中选出一个节点作为新的主节点, 这个新的主节点将接管原来节点7000处理的槽, 并继续处理客户端发出的命令. 如果节点7004被选中为新的主节点, 那么节点7004将接管原来由7000负责处理的槽, 节点7005也会从原来的复制节点7000, 改为复制节点7004.如果在故障转移完后之后, 下线的节点7000重新上线, 它将称为节点7004的从节点. 

  - ### 设置从节点

  向一个发送命令:
  CLUSTER REPLICATE <node_id>
  可以让接受命令的节点成为 node_id 所指定节点的从节点, 并开始对
  主节点进行复制. 